#version 450

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;

layout(r32f, binding = 0) uniform image3D field;

layout(std430, binding = 1) buffer posBuff {
    vec4 pos[];
};
layout(std430, binding = 2) buffer velBuff {
    vec4 vel[];
};

layout(rgba32f, binding = 3) writeonly uniform image2D outImg;

layout(binding = 4) uniform Config {
   float frontness;
   float speed;
   float radius;
   float randomness;
};

#define OCTAVES 6.
#define PI 3.14159265359
#define TWOPI 6.28318530718 

uint wang_hash(inout uint seed){

    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float RandomFloat01(inout uint seed) { 
    return float(wang_hash(seed)) / 4294967296.0; 
}

vec3 randomUnitVector3(inout uint seed){

    float z = RandomFloat01(seed) * 2.0f - 1.0f;
    float a = RandomFloat01(seed) * TWOPI;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

float readImage3DTrilinear(vec3 uvw) {
    ivec3 imgSize = imageSize(field);
    vec3 pos = uvw * vec3(imgSize) - 0.5;

    ivec3 p0 = ivec3(floor(pos));
    ivec3 p1 = p0 + ivec3(1);
    p0 = clamp(p0, ivec3(0), imgSize - 1);
    p1 = clamp(p1, ivec3(0), imgSize - 1);

    vec3 f = fract(pos);

    float c000 = imageLoad(field, p0).x;
    float c100 = imageLoad(field, ivec3(p1.x, p0.y, p0.z)).x;
    float c010 = imageLoad(field, ivec3(p0.x, p1.y, p0.z)).x;
    float c110 = imageLoad(field, ivec3(p1.x, p1.y, p0.z)).x;

    float c001 = imageLoad(field, ivec3(p0.x, p0.y, p1.z)).x;
    float c101 = imageLoad(field, ivec3(p1.x, p0.y, p1.z)).x;
    float c011 = imageLoad(field, ivec3(p0.x, p1.y, p1.z)).x;
    float c111 = imageLoad(field, p1).x;

    float c00 = mix(c000, c100, f.x);
    float c10 = mix(c010, c110, f.x);
    float c01 = mix(c001, c101, f.x);
    float c11 = mix(c011, c111, f.x);

    float c0 = mix(c00, c10, f.y);
    float c1 = mix(c01, c11, f.y);

    return mix(c0, c1, f.z);
}

void main()
{
    const int coord = int(gl_GlobalInvocationID.x);
    if (coord >= 490000) return;

    vec4 p = pos[coord];
    vec4 v = vel[coord];

    uint seed = uint(coord*3) + uint((p.x+2)*9999) + uint((p.y+2)*9999) + uint((p.z+2)*9999);

    vec3 front = normalize(v.xyz);
    vec3 up0   = vec3(0,1,0);
    vec3 up    = normalize(up0 - front * dot(up0, front)); // Gram-Schmidt
    vec3 right = cross(up, front); // unit, no normalize needed


    vec3 senseDir[5];
    senseDir[0] = front;
    senseDir[1] = right;
    senseDir[2] = -right;
    senseDir[3] = up;
    senseDir[4] = -up;

    vec3 meanDir = vec3(0.0);
    float weight = 0.0;

    for(int i = 0; i < 5; i++){
        senseDir[i] = normalize(senseDir[i] + front*frontness);
        vec3 g = (p.xyz*0.5 + 0.5) + senseDir[i]*radius;
        if(g.x < 0.0 || g.y < 0.0 || g.z < 0.0 || g.x >= 1.0 || g.y >= 1.0 || g.z >= 1.0) continue;
        float density = readImage3DTrilinear(g);// * mix(0.9, 1.0, RandomFloat01(seed));
        meanDir += senseDir[i] * density;
        weight += density;
    }

    meanDir += randomUnitVector3(seed)*randomness;

    v.xyz = weight > 0.0 ? normalize(meanDir) : front;
    v.xyz *= speed;

    vec3 nextPos = p.xyz + v.xyz;

    vec3 change = vec3( float(nextPos.x > -1.0 && nextPos.x < 1.0 ),
                        float(nextPos.y > -1.0 && nextPos.y < 1.0 ),
                        float(nextPos.z > -1.0 && nextPos.z < 1.0 )
                    )*2 - 1;

    v.xyz *= change;

    //pos[coord] = mod(pos[coord] + 1.0, 2.0) - 1.0;
    ivec3 gridPos = ivec3((p.xyz*0.5 + 0.5) * 512);
    float curr = imageLoad(field, gridPos).x;

    float toWrite = weight > 0.0 ? max(10, curr + 0.01) : max(10,curr);//max(curr, weight/5);
    p.w = toWrite;
    imageStore(field, gridPos, vec4(toWrite));

    p.xyz += v.xyz;//*RandomFloat01(seed);
    imageStore(outImg, ivec2(coord % 700, int(float(coord) / 700.0)), p);

    pos[coord] = p;
    vel[coord] = v;
}
