#version 460

layout(local_size_x = 16, local_size_y = 16, local_size_z = 4) in;

layout(binding = 0, rgba32f) readonly uniform image2D posImg;

layout(std430, binding = 1) buffer countBuff {
    uint count;      
    uint counter[];
};

layout(binding = 2, rgba32f) writeonly uniform image2D canvasImg;

layout(std430, set = 0, binding = 3) buffer grid {
    uint cell[];
};

layout(binding = 4) uniform Config {
    uint numLevels;
};

const uint MAX_COUNT = 1024u;
shared vec3 center_radius[MAX_COUNT];
shared vec3 res[1024u];

ivec2 wrapID(uint id, ivec2 posImgSize) {
    int w = posImgSize.x;
    int x = int(id % uint(w));
    int y = int(id / uint(w));
    return ivec2(x, y);
}

void main() {

    ivec2 gid  = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(canvasImg);
    if (gid.x >= size.x || gid.y >= size.y) return;

    uint idz = gl_LocalInvocationID.z;

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
    uint xyLocalInvocationIndex = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;
/*
    for(uint i = 0; i < gl_WorkGroupSize.z; i++){
        res[xyLocalInvocationIndex + threadCount*i] = vec3(0.0);
    }
*/
    res[gl_LocalInvocationIndex] = vec3(0.0);
    barrier();

    vec2 fgid  = vec2(gid);
    vec2 fsize = vec2(size);

    ivec2 posImgSize = imageSize(posImg);

    float invCellSize = 1.0;  // cellSize = div
    uint  baseOffset = 0u;   // base offset for the current level

    vec2 pixelCenter = vec2(gid) + vec2(0.5);

    const vec3 colors[6] = vec3[](  vec3(1,0,0),
                                    vec3(0,1,0),
                                    vec3(0,0,1),
                                    vec3(1,1,0),
                                    vec3(0,1,1),
                                    vec3(1,0,1));

    // Per ogni livello
    for (uint level = 0u; level < min(numLevels, 4); ++level) {
    //for (uint level = 0u; level < numLevels; ++level) {

        uint levelWidth  = uint(ceil(fsize.x * invCellSize));
        uint levelHeight = uint(ceil(fsize.y * invCellSize));

        // Cell's coordinates at this level
        uint lx = min(uint(fgid.x * invCellSize), levelWidth  - 1u);
        uint ly = min(uint(fgid.y * invCellSize), levelHeight - 1u);

        uint coord = baseOffset + lx + ly * levelWidth;

        // Read the number of particles in this cell, clamped to MAX_COUNT
        uint particleCount = min(counter[coord], MAX_COUNT);

        if(particleCount == 0u){
            baseOffset += levelWidth * levelHeight;
            invCellSize *= 0.5;
            continue;
        } 

        uint slices = gl_WorkGroupSize.z;
        uint partPerSlice = (particleCount + slices - 1u) / slices; // ceil

        uint sliceStart = partPerSlice * idz;

        vec3 localRes = vec3(0.0);

        if (sliceStart >= particleCount) {
            //Do nothing, and pass to the next level
            //Update the offset for the next level
            baseOffset += levelWidth * levelHeight;
            invCellSize *= 0.5;
            continue;

        } else {

            uint sliceEnd = min(sliceStart + partPerSlice, particleCount);
            uint first = coord * MAX_COUNT;

            vec3 color = colors[level % 6] * 0.001;
            //vec3 color = vec3(0.003);

            for (uint k = sliceStart; k < sliceEnd; ++k) {

                uint id = cell[first + k];
                ivec2 particleTexel = wrapID(id, posImgSize);
                vec3 center = imageLoad(posImg, particleTexel).xyz;// center.xy = pos in pixel, center.z = radius in pixel
                vec2 diff = center.xy - pixelCenter;
                float dist2 = dot(diff, diff);

                localRes += (dist2 <= center.z) ? color : vec3(0.0);
            }

            res[xyLocalInvocationIndex + threadCount*idz] += localRes;
        }

        // Update the offset for the next level
        baseOffset += levelWidth * levelHeight;
        invCellSize *= 0.5;
    }

    // Continue with the levels larger than the workgroup size (XY)
    for (uint level = 4u; level < numLevels; ++level) {

        uint levelWidth  = uint(ceil(fsize.x * invCellSize));
        uint levelHeight = uint(ceil(fsize.y * invCellSize));

        // Cell's coordinates at his level
        uint lx = min(uint(fgid.x * invCellSize), levelWidth  - 1u);
        uint ly = min(uint(fgid.y * invCellSize), levelHeight - 1u);

        uint coord = baseOffset + lx + ly * levelWidth;

        // Read the number of particles in this cell, clamped to MAX_COUNT
        uint particleCount = min(counter[coord], MAX_COUNT);

        if(particleCount == 0u){
            baseOffset += levelWidth * levelHeight;
            invCellSize *= 0.5;
            continue;
        } 

        uint first = coord * MAX_COUNT;

/*
        //cooperatively load the particles into the shared memory
        for (uint k = gl_LocalInvocationIndex; k < particleCount; k += threadCount) {

            uint id = cell[first + k];

            ivec2 particleTexel = wrapID(id, posImgSize);
            center_radius[k] = imageLoad(posImg, particleTexel).xyz;
        }            
*/
        if(gl_LocalInvocationIndex < particleCount){

            uint id = cell[first + gl_LocalInvocationIndex];
            ivec2 particleTexel = wrapID(id, posImgSize);
            center_radius[gl_LocalInvocationIndex] = imageLoad(posImg, particleTexel).xyz;
        }

        barrier();

        uint slices = gl_WorkGroupSize.z;
        uint partPerSlice = (particleCount + slices - 1u) / slices; // ceil

        uint sliceStart = partPerSlice * idz;

        vec3 localRes = vec3(0.0);

        if (sliceStart >= particleCount) {
            //Do nothing, and pass to the next level
            //Update the offset for the next level
            baseOffset += levelWidth * levelHeight;
            invCellSize *= 0.5;
            continue;

        } else {

            uint sliceEnd = min(sliceStart + partPerSlice, particleCount);
            uint first = coord * MAX_COUNT;

            vec3 color = colors[level % 6] * 0.001;
            //vec3 color = vec3(0.003);

            for (uint k = sliceStart; k < sliceEnd; ++k) {

                vec2 diff = center_radius[k].xy - pixelCenter;
                float dist2 = dot(diff, diff);

                localRes += (dist2 <= center_radius[k].z) ? color : vec3(0.0);
            }

            res[xyLocalInvocationIndex + threadCount*idz] += localRes;
        }

        // Update the offset for the next level
        baseOffset += levelWidth * levelHeight;
        invCellSize *= 0.5;
    }

    barrier();

    if(idz == 0){

        vec3 accum = vec3(0.0);
        for(uint i = 0; i < gl_WorkGroupSize.z; i++){
            accum += res[xyLocalInvocationIndex + threadCount*i];
        }
        imageStore(canvasImg, gid, vec4(accum, 1.0));
    }
}
