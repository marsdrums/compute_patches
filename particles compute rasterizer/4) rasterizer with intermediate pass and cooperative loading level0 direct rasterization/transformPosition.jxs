#version 460

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba32f) uniform image2D posImg;
layout(binding = 1, r32ui) uniform uimage2D smallParticlesCanvas;

layout(std430, binding = 2) buffer countBuff {
    uint count;      // non usato direttamente, ma resta per layout
    uint counter[];  // contatori per cella (tutti i livelli)
};

layout(std430, set = 0, binding = 3) buffer grid {
    uint cell[];     // liste di particelle per cella (tutti i livelli)
};

layout(binding = 4) uniform Config {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 v3;
    vec4 p0;
    vec4 p1;
    vec4 p2;
    vec4 p3;
    vec2 viewPort;   // dimensioni in pixel della finestra
    uint numLevels;  // numero di livelli della griglia
};

const float radiusWorld = 0.001; // radius in world space
const uint MAX_COUNT = 1024u;
const float focal_dist = 2.0;
const float dof = 8.0;

shared mat4 V;
shared mat4 P;
shared uint offset[12];
shared vec4 radiusOffsetProj;

uint getLinearID(ivec2 gid, ivec2 size) {
    return uint(gid.x + gid.y * size.x);
}

// Ritorna la più piccola potenza di due >= n, e il livello corrispondente
uint nextPow2(uint n, out uint level) {
    uint thisPower = 1u;
    for (uint i = 0u; i < numLevels; ++i) {
        if (n <= thisPower) {
            level = i;
            return thisPower;
        }
        thisPower <<= 1; // *= 2
    }

    // Se n è più grande dell'ultimo livello, clamp all'ultimo
    level = numLevels - 1u;
    return thisPower >> 1; // ultima potenza valida
}

// Offset nel buffer di contatori/ celle per il livello richiesto
uint calcOffset(uint level) {
    float thisPower = 1.0;
    uint offset = 0u;
    // Somma tutte le celle dei livelli precedenti
    for (uint i = 0u; i < level; ++i) {
        offset += uint(ceil(viewPort.x / thisPower)) *
                  uint(ceil(viewPort.y / thisPower));
        thisPower *= 2.0;
    }
    return offset;
}

void build_matrices(){

    if(gl_LocalInvocationIndex == 0){

        // Build matrices
        V = mat4(v0, v1, v2, v3);
        P = mat4(-p0, p1, -p2, p3);
    }
}

void compute_pyramid_data(){

    if(gl_LocalInvocationIndex < 12){

        // Compute base offset for this level
        offset[gl_LocalInvocationIndex] = calcOffset(gl_LocalInvocationIndex);
    }
}

void compute_radius_offset_in_clip_space(){

    if(gl_LocalInvocationIndex == 0){

        radiusOffsetProj = P * vec4(radiusWorld, 0.0, 0.0, 0.0);
    }
}

void main() {

    ivec2 gid  = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(posImg);
    if (gid.x >= size.x || gid.y >= size.y) return;

    uint partID = getLinearID(gid, size);
    vec3 pos    = imageLoad(posImg, gid).xyz;

    build_matrices();
    barrier();

    compute_pyramid_data();
    barrier();

    compute_radius_offset_in_clip_space();
    barrier();

    vec4 vPos     = V * vec4(pos, 1.0);
    vec4 projPos  = P * vPos;
    vec2 ndcPos   = projPos.xy / projPos.w;  // NDC [-1,1]

    if(
        ndcPos.x < -1.0 || ndcPos.x > 1.0 ||
        ndcPos.y < -1.0 || ndcPos.y > 1.0 ||
        vPos.z >= -0.01){

        return;
    }

    // NDC -> [0,1] -> pixel
    vec2 screenPos = (ndcPos * 0.5 + 0.5) * viewPort;

    vec4 offsetProj  = projPos + radiusOffsetProj;
    vec2 offsetNDC   = offsetProj.xy / offsetProj.w;
    vec2 offsetPixel = (offsetNDC * 0.5 + 0.5) * viewPort;

    float radiusOnScreen = offsetPixel.x - screenPos.x;
    //radiusOnScreen *= dof*abs(-vPos.z - focal_dist) + 1.0;
    

    if(radiusOnScreen <= 0.5){
        //rasterize directly

        float dimmer = 2*radiusOnScreen;
        dimmer *= dimmer;
        uint colorToAdd = uint(4294967295.0 * 0.003 * dimmer);
        //uint colorToAdd = uint(4294967295.0 * 0.003);
        imageAtomicAdd(smallParticlesCanvas, ivec2(screenPos.xy), colorToAdd);

    } else {

        //use the intermediate grid

        //radiusOnScreen = max(0.5, radiusOnScreen); // at least half-pixel

        // Store position in pixels + radius
        imageStore(posImg, gid, vec4(screenPos.xy, radiusOnScreen * radiusOnScreen, 0.0));

        // Diameter size in pixels
        float fSizeOnfScreen = ceil(radiusOnScreen * 2.0);
        uint sizeOnScreen = uint(fSizeOnfScreen);

        // Select the level based on the size on screen
        uint level = uint(floor(log2(fSizeOnfScreen)));
        uint cellSizePixels = 1u << level;//uint(pow(2.0, float(level)));  // cellSize = 1,2,4,...

        float cellSize     = float(cellSizePixels);
        float invCellSize  = 1.0 / cellSize;

        float minXf = (screenPos.x - radiusOnScreen) * invCellSize;
        float maxXf = (screenPos.x + radiusOnScreen) * invCellSize;
        float minYf = (screenPos.y - radiusOnScreen) * invCellSize;
        float maxYf = (screenPos.y + radiusOnScreen) * invCellSize;

        int mapWidth  = int(ceil(viewPort.x * invCellSize));
        int mapHeight = int(ceil(viewPort.y * invCellSize));

        // Quantization + clamping (inclusive)
        int ixMin = int(floor(minXf));
        int ixMax = int(ceil (maxXf)) - 1;
        int iyMin = int(floor(minYf));
        int iyMax = int(ceil (maxYf)) - 1;


        //if (ixMax < ixMin || iyMax < iyMin) return;

        for (int y = iyMin; y <= iyMax; ++y) {

            int row = y * mapWidth;

            for (int x = ixMin; x <= ixMax; ++x) {

                uint coord = offset[level] + uint(x + row);

                // Atomically update the counter
                uint oldCount = atomicAdd(counter[coord], 1u);

                // Store this particle ID
                if (oldCount < MAX_COUNT) {
                    cell[coord * MAX_COUNT + oldCount] = partID;
                }
            }
        }
    }
}
