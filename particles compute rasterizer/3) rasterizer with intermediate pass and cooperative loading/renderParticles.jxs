#version 460

layout(local_size_x = 16, local_size_y = 16, local_size_z = 4) in;

layout(binding = 0, rgba32f) readonly uniform image2D posImg;

layout(std430, binding = 1) buffer countBuff {
    uint count;      
    uint counter[];
};

layout(binding = 2, rgba32f) writeonly uniform image2D canvasImg;

layout(std430, set = 0, binding = 3) buffer grid {
    uint cell[];
};

layout(binding = 4) uniform Config {
    uint numLevels;
};

const uint MAX_COUNT = 1024u;
shared vec3 center_radius[MAX_COUNT];
shared vec3 res[1024u];

ivec2 wrapID(uint id, ivec2 posImgSize) {
    int w = posImgSize.x;
    int x = int(id % uint(w));
    int y = int(id / uint(w));
    return ivec2(x, y);
}

void main() {

    ivec2 gid  = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(canvasImg);
    if (gid.x >= size.x || gid.y >= size.y) return;

    uint idz = gl_LocalInvocationID.z;

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y;
    uint xyLocalInvocationIndex = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;

    res[xyLocalInvocationIndex] = vec3(0.0);
    res[xyLocalInvocationIndex + threadCount] = vec3(0.0);
    res[xyLocalInvocationIndex + threadCount*2] = vec3(0.0);
    res[xyLocalInvocationIndex + threadCount*3] = vec3(0.0);

    barrier();

    vec2 fgid  = vec2(gid);
    vec2 fsize = vec2(size);

    ivec2 posImgSize = imageSize(posImg);

    float invCellSize = 1.0;  // cellSize = div
    uint  baseOffset = 0u;   // base offset for the current level

    vec2 pixelCenter = vec2(gid) + vec2(0.5);

    const vec3 colors[6] = vec3[](  vec3(1,0,0),
                                    vec3(0,1,0),
                                    vec3(0,0,1),
                                    vec3(1,1,0),
                                    vec3(0,1,1),
                                    vec3(1,0,1));

    // Per ogni livello
    for (uint level = 0u; level < min(numLevels, 4); ++level) {
    //for (uint level = 0u; level < numLevels; ++level) {

        uint levelWidth  = uint(ceil(fsize.x * invCellSize));
        uint levelHeight = uint(ceil(fsize.y * invCellSize));

        // Cell's coordinates at his level
        uint lx = min(uint(fgid.x * invCellSize), levelWidth  - 1u);
        uint ly = min(uint(fgid.y * invCellSize), levelHeight - 1u);

        uint coord = baseOffset + lx + ly * levelWidth;

        // Read the number of particles in this cell, clamped to MAX_COUNT
        uint particleCount = min(counter[coord], MAX_COUNT);

        uint partPerSlice = uint(particleCount / gl_WorkGroupSize.z);

        uint sliceStart = partPerSlice * idz;
        uint sliceEnd = min(partPerSlice * (idz+1), particleCount);

        uint first = coord * MAX_COUNT;

        for (uint k = sliceStart; k < sliceEnd; ++k) {

            uint id = cell[first + k];

            ivec2 particleTexel = wrapID(id, posImgSize);
            vec3 center = imageLoad(posImg, particleTexel).xyz;// center.xy = pos in pixel, center.z = radius in pixel

            vec2 diff = center.xy - pixelCenter;

            float dist2 = dot(diff, diff);
            res[xyLocalInvocationIndex + threadCount*idz] +=    (dist2 <= center.z) ? 
                                                                colors[level % 6] * 0.001 :
                                                                vec3(0.0);
        }

        // Update the offset for the next level
        baseOffset += levelWidth * levelHeight;
        invCellSize *= 0.5;
    }

    // Continue with the levels larger than the workgroup size (XY)
    for (uint level = 4u; level < numLevels; ++level) {

        uint levelWidth  = uint(ceil(fsize.x * invCellSize));
        uint levelHeight = uint(ceil(fsize.y * invCellSize));

        // Cell's coordinates at his level
        uint lx = min(uint(fgid.x * invCellSize), levelWidth  - 1u);
        uint ly = min(uint(fgid.y * invCellSize), levelHeight - 1u);

        uint coord = baseOffset + lx + ly * levelWidth;

        // Read the number of particles in this cell, clamped to MAX_COUNT
        uint particleCount = min(counter[coord], MAX_COUNT);

        uint first = coord * MAX_COUNT;

        //cooperatively load the particles into the shared memory
        for (uint k = gl_LocalInvocationIndex; k < particleCount; k += threadCount) {

            uint id = cell[first + k];

            ivec2 particleTexel = wrapID(id, posImgSize);
            center_radius[k] = imageLoad(posImg, particleTexel).xyz;
        }            

        barrier();

        uint partPerSlice = uint(particleCount / gl_WorkGroupSize.z);

        uint sliceStart = partPerSlice * idz;
        uint sliceEnd = min(partPerSlice * (idz+1), particleCount);

        for(uint p = sliceStart; p < sliceEnd; p++){

            vec2 diff = center_radius[p].xy - pixelCenter;

            float dist2 = dot(diff, diff);
            res[xyLocalInvocationIndex + threadCount*idz] +=    (dist2 <= center_radius[p].z) ? 
                                                                colors[level % 6] * 0.001 :
                                                                vec3(0.0);
        }

        // Update the offset for the next level
        baseOffset += levelWidth * levelHeight;
        invCellSize *= 0.5;
    }

    barrier();

    if(idz == 0){
        imageStore(canvasImg, gid, vec4(    res[xyLocalInvocationIndex] + 
                                            res[xyLocalInvocationIndex + threadCount] + 
                                            res[xyLocalInvocationIndex + threadCount*2] + 
                                            res[xyLocalInvocationIndex + threadCount*3], 
                                            1.0));
    }
}
