#version 460

// ------------------------------------------------------------
// OVERVIEW
// ------------------------------------------------------------
// This compute shader "render-merges" / resolves the pyramid grid levels
// produced by the splat shader into a final render image.
//
// Each pixel (gid) accumulates contributions from:
//   - level 0 at exact pixel coordinate (gid)
//   - levels 1..MAX_LEVELS-1 at coordinates (gid >> L)
//     (i.e., pixel maps into a coarser cell by dividing by 2^L)
//
// The grid pyramid is stored in a single SSBO `cell[]` with per-level offsets.
// Values are uint accumulators (0..2^32-1). We convert to float via invMax.
//
// Performance strategy:
//   - Level 0 is unique per pixel -> read directly from global SSBO.
//   - Levels 1..10 are *shared* across neighboring pixels -> cache the subset
//     of cells that this 32x32 workgroup needs into shared memory (sCache[]).
//     Each thread then reads cached values instead of repeatedly re-reading SSBO.
//
// Border correctness:
//   - We must not early-return before barriers (workgroup cooperation).
//   - Near image borders / pyramid edges, clamping and a "rare fallback" path
//     ensures coordinates remain valid even if cache mapping misses.
// ------------------------------------------------------------

layout(local_size_x = 32, local_size_y = 32) in;

// ------------------------------------------------------------
// INPUT PYRAMID GRID
// ------------------------------------------------------------
// Flat SSBO of uint cells. Layout is level 0, then level 1, etc.
// offset[L] stores the starting index of that level in cell[].
layout(std430, set = 0, binding = 0) buffer grid {
    uint cell[];
};

// Output image where final merged intensity is written.
layout(binding = 1, rgba32f) writeonly uniform image2D renderImg;

// Compatibility-only uniform; bufferSize unused here.
layout(binding = 2) uniform Config {
    uint bufferSize; // kept for compatibility; not used
};

#define MAX_LEVELS 11

// ------------------------------------------------------------
// SHARED PYRAMID METADATA (PER WORKGROUP)
// ------------------------------------------------------------
// These are computed once per workgroup (by local invocation 0) and then
// used by all lanes.
shared int levelWidth[MAX_LEVELS];   // width of each level in cells
shared int levelHeight[MAX_LEVELS];  // height of each level in cells
shared int offset[MAX_LEVELS];       // base offsets into cell[] per level

// ------------------------------------------------------------
// SHARED CACHE LAYOUT (PER WORKGROUP)
// ------------------------------------------------------------
// For each level L, figure out which coarse cells are needed to cover the
// 32x32 pixel tile processed by this workgroup.
//
// wgMinCoord[L] : minimum (x,y) cell coordinate at level L covered by this WG tile
// wgSpanX/Y[L]  : dimensions of the covered rectangle in that level
// cacheBase[L]  : start index in sCache[] where this level's rectangle is stored
// totalCacheEntries: total entries reserved across all levels (1..10)
shared ivec2 wgMinCoord[MAX_LEVELS];
shared int   wgSpanX[MAX_LEVELS];
shared int   wgSpanY[MAX_LEVELS];
shared int   cacheBase[MAX_LEVELS];
shared int   totalCacheEntries;

// ------------------------------------------------------------
// SHARED CACHE STORAGE (LEVELS >= 1)
// ------------------------------------------------------------
// sCache is a linear array containing concatenated rectangles for each level.
// Size analysis for 32x32 workgroup:
//   - At L=1, each cell is 2x2 pixels -> WG spans up to 17x17 cells
//   - At L=2 -> up to 9x9 cells
//   - ...
// Summed worst-case is ~420 entries, so 512 is safe.
//
// NOTE: Level 0 is not cached because it's 1:1 per pixel (no reuse).
const int MAX_CACHE = 512;
shared uint sCache[MAX_CACHE];

// ------------------------------------------------------------
// coord2id
// ------------------------------------------------------------
// Convert (coord, level) into a linear SSBO index.
uint coord2id(ivec2 coord, int level)
{
    return uint(coord.x + coord.y * levelWidth[level] + offset[level]);
}

// ------------------------------------------------------------
// decodeCacheIndex
// ------------------------------------------------------------
// Given a global cache index k (0..totalCacheEntries-1), determine:
//   L        : which pyramid level's slice contains k
//   localIdx : index within that slice
//
// Cache slices are packed sequentially by level:
//   slice(L) occupies [cacheBase[L], cacheBase[L] + wgSpanX[L]*wgSpanY[L])
//
// Cost note:
//   This is a small linear search over 10 levels.
//   It's only used during the cooperative load phase and is usually cheap
//   compared to SSBO reads it helps eliminate.
void decodeCacheIndex(int k, out int L, out int localIdx)
{
    // Find which level slice contains k (levels 1..10 only)
    // cacheBase[L] holds the starting index in sCache for that level.
    // size of slice is wgSpanX[L] * wgSpanY[L].
    for (int lev = 1; lev < MAX_LEVELS; ++lev)
    {
        int base = cacheBase[lev];
        int size = wgSpanX[lev] * wgSpanY[lev];
        if (k >= base && k < base + size)
        {
            L = lev;
            localIdx = k - base;
            return;
        }
    }
    // If not found, mark invalid.
    L = -1;
    localIdx = 0;
}

void main()
{
    // Global pixel coordinate this invocation is responsible for.
    ivec2 gid  = ivec2(gl_GlobalInvocationID.xy);

    // Output image size; also the "true" base resolution for level 0.
    ivec2 size = imageSize(renderImg);

    // ------------------------------------------------------------
    // IMPORTANT BARRIER RULE
    // ------------------------------------------------------------
    // We cannot early-return before barriers because the whole workgroup
    // cooperates to build shared data and fill shared cache.
    //
    // Instead, we compute a flag and return only after cache is ready.
    bool isActive = (gid.x >= 0 && gid.y >= 0 && gid.x < size.x && gid.y < size.y);

    // Workgroup covers a fixed 32x32 pixel tile in base level (level 0).
    // wgOrigin = top-left pixel of this workgroup's tile
    // wgEnd    = bottom-right pixel (inclusive) of this tile
    ivec2 wgOrigin = ivec2(gl_WorkGroupID.xy) * ivec2(gl_WorkGroupSize.xy); // 32x32 tiles
    ivec2 wgEnd    = wgOrigin + ivec2(int(gl_WorkGroupSize.x) - 1, int(gl_WorkGroupSize.y) - 1); // +31

    // ------------------------------------------------------------
    // WORKGROUP-ONE-TIME INIT
    // ------------------------------------------------------------
    if (gl_LocalInvocationIndex == 0u)
    {
        int runningOffset = 0;

        // ---- Build pyramid dimensions and SSBO offsets ----
        // For each level L:
        //   s = 2^L pixels per cell
        //   w = ceil(size.x / s)
        //   h = ceil(size.y / s)
        //
        // Ceil-div implemented as:
        //   ceil(x / s) = (x + s - 1) / s
        // Since s is power-of-two, /s becomes >>L.
        for (int L = 0; L < MAX_LEVELS; ++L)
        {
            int s = 1 << L; // 2^L
            int w = (size.x + (s - 1)) >> L; // ceil(size / 2^L)
            int h = (size.y + (s - 1)) >> L;

            levelWidth[L]  = w;
            levelHeight[L] = h;

            // Flat buffer layout: levels packed one after another.
            offset[L] = runningOffset;
            runningOffset += w * h;
        }

        // ---- Build per-level cache rectangles for levels >= 1 ----
        // We determine which *cells* at each level overlap this WG's 32x32 pixel tile.
        //
        // For a pixel tile [wgOrigin..wgEnd], the corresponding level-L cell coords are:
        //   mn = floor(wgOrigin / 2^L) = wgOrigin >> L
        //   mx = floor(wgEnd    / 2^L) = wgEnd    >> L
        //
        // That gives an inclusive rectangle of cells that every pixel in this tile
        // might sample from at level L.
        int runningCache = 0;

        // Level 0 not cached.
        cacheBase[0] = 0;
        wgMinCoord[0] = ivec2(0);
        wgSpanX[0] = 0;
        wgSpanY[0] = 0;

        for (int L = 1; L < MAX_LEVELS; ++L)
        {
            ivec2 mn = wgOrigin >> L;
            ivec2 mx = wgEnd    >> L;

            // Clamp to valid cell coords at level L, because at image borders
            // the workgroup's tile can extend beyond the image, and pyramid
            // levels are ceil-div sized.
            ivec2 last = ivec2(levelWidth[L] - 1, levelHeight[L] - 1);
            mn = clamp(mn, ivec2(0), last);
            mx = clamp(mx, ivec2(0), last);

            // Inclusive span -> +1.
            ivec2 span = mx - mn + ivec2(1);

            wgMinCoord[L] = mn;
            wgSpanX[L]    = span.x;
            wgSpanY[L]    = span.y;

            // Cache slices are packed sequentially by level.
            cacheBase[L]  = runningCache;
            runningCache += span.x * span.y;
        }

        // Safety: clamp cache size if something changes (WG size, MAX_LEVELS).
        // If runningCache exceeds MAX_CACHE, some entries will not be cached.
        // (In that case later reads may fall back to global reads.)
        totalCacheEntries = min(runningCache, MAX_CACHE);
    }

    // Ensure metadata + cache layout are visible to all threads.
    barrier();

    // ------------------------------------------------------------
    // COOPERATIVE CACHE LOAD (LEVELS >= 1)
    // ------------------------------------------------------------
    // We want to fill sCache[] with the level>=1 cells needed by this WG.
    // Each thread loads multiple cache entries striding by total threads.
    uint tid = gl_LocalInvocationIndex;
    uint wgThreads = gl_WorkGroupSize.x * gl_WorkGroupSize.y;

    for (uint k = tid; int(k) < totalCacheEntries; k += wgThreads)
    {
        int L, localIdx;
        decodeCacheIndex(int(k), L, localIdx);

        if (L > 0)
        {
            // Convert localIdx -> (dx,dy) within this level's cached rectangle.
            // Row-major:
            //   dx = localIdx % spanX
            //   dy = localIdx / spanX
            int sx = wgSpanX[L];
            int dx = localIdx % sx;
            int dy = localIdx / sx;

            // Convert tile-local (dx,dy) into absolute level coords.
            ivec2 coord = wgMinCoord[L] + ivec2(dx, dy);

            // Robustness: coord should already be clamped by thread0â€™s mn/mx,
            // but clamp again in case of unexpected issues.
            ivec2 last = ivec2(levelWidth[L] - 1, levelHeight[L] - 1);
            coord = clamp(coord, ivec2(0), last);

            // Global SSBO read once, stored in shared cache for many pixels to reuse.
            uint id = coord2id(coord, L);
            sCache[int(k)] = cell[id];
        }
        else
        {
            // If decode failed, just store 0 to avoid undefined reads later.
            sCache[int(k)] = 0u;
        }
    }

    // Ensure cache is fully populated before any pixel uses it.
    barrier();

    // Now it's safe to drop inactive out-of-bounds invocations.
    if (!isActive)
        return;

    // Convert uint accumulator (0..2^32-1) to float [0..1] scale.
    // (This assumes upstream uses 4294967295 scaling in emit.)
    const float invMax = 1.0 / 4294967295.0;

    float res = 0.0;

    // ------------------------------------------------------------
    // LEVEL 0 MERGE (PER-PIXEL, NO CACHE)
    // ------------------------------------------------------------
    // Level 0 grid is exactly the pixel grid, so each pixel reads one unique cell.
    // Caching would not help (no reuse within the workgroup for level 0).
    {
        ivec2 coord0 = gid;
        uint id0 = coord2id(coord0, 0);

        // fma(a,b,c) = a*b + c
        // Using FMA can reduce rounding and may compile to a single instruction.
        res = fma(float(cell[id0]), invMax, res);
    }

    // ------------------------------------------------------------
    // LEVELS 1..10 MERGE (CACHED WITH FALLBACK)
    // ------------------------------------------------------------
    // Each higher level represents coarser coverage. For a pixel gid:
    //   coord(L) = gid / 2^L = gid >> L
    //
    // We sum contributions from all levels into one scalar "res".
    // (This is a straightforward additive merge; no normalization by area here.)
    #pragma unroll
    for (int L = 1; L < MAX_LEVELS; ++L)
    {
        // Pixel -> cell coordinate at level L.
        ivec2 coord = gid >> L;

        // Clamp to ensure we don't address beyond the level's dimensions.
        ivec2 last = ivec2(levelWidth[L] - 1, levelHeight[L] - 1);
        coord = clamp(coord, ivec2(0), last);

        // Map this coord into our cached rectangle for level L.
        // Cached rectangle is [wgMinCoord[L] .. wgMinCoord[L] + span-1].
        ivec2 mn = wgMinCoord[L];
        int dx = coord.x - mn.x;
        int dy = coord.y - mn.y;

        // If coord is within cached tile -> read from sCache.
        // Otherwise -> rare border case -> read directly from SSBO.
        //
        // Why could it be outside?
        //  - Near image borders, clamping can cause different pixels in a WG to map
        //    to a coord that isn't inside the computed [mn..mx] (depending on how
        //    mn/mx clamped + ceil-div levels interact).
        //  - Or if totalCacheEntries was clamped by MAX_CACHE (future-proofing).
        uint v;
        if (dx >= 0 && dy >= 0 && dx < wgSpanX[L] && dy < wgSpanY[L])
        {
            int idx = cacheBase[L] + dx + dy * wgSpanX[L];

            // Additional safety: if idx exceeds totalCacheEntries (e.g. MAX_CACHE clamp),
            // fall back to SSBO read.
            v = (idx >= 0 && idx < totalCacheEntries) ? sCache[idx]
                                                      : cell[coord2id(coord, L)];
        }
        else
        {
            v = cell[coord2id(coord, L)];
        }

        // Accumulate normalized level contribution.
        res = fma(float(v), invMax, res);
    }

    // Write grayscale output with alpha=1.
    imageStore(renderImg, gid, vec4(vec3(res), 1.0));
}
