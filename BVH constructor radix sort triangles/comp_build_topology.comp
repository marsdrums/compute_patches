#version 460
layout(local_size_x = 256) in;

struct Key {
    uint morton;
    uint primID;
};

layout(std430, binding = 0) buffer readonly buff_normPos { Key key[]; };
layout(std430, binding = 1) buffer writeonly buff_nodeParent { int nodeParent[]; };
layout(std430, binding = 2) buffer writeonly buff_nodeAabbMin { vec4 nodeAabbMin[]; };
layout(std430, binding = 3) buffer writeonly buff_nodeAabbMax { vec4 nodeAabbMax[]; };
layout(        binding = 4) uniform cfg { uint N; };

int clz32(uint x) {
    if (x == 0u) return 32;
    return 31 - findMSB(x);
}

int deltaIdx(int i, int j) {
    if (j < 0 || j >= int(N)) return -1;

    uint a = key[i].morton;
    uint b = key[j].morton;

    if (a != b) return clz32(a ^ b);

    uint x = uint(i) ^ uint(j);
    return 32 + clz32(x);
}

void main() {
    int i = int(gl_GlobalInvocationID.x);

    if (i >= int(N) - 1) return; // N-1 nodi interni

    // 1) Direzione
    int d = (deltaIdx(i, i + 1) - deltaIdx(i, i - 1)) >= 0 ? 1 : -1;

    // 2) Range length (exponential search + binary refine)
    int deltaMin = deltaIdx(i, i - d);

    int lmax = 2;
    while (deltaIdx(i, i + lmax * d) > deltaMin) {
        lmax <<= 1;
    }

    int l = 0;
    for (int t = lmax >> 1; t >= 1; t >>= 1) {
        if (deltaIdx(i, i + (l + t) * d) > deltaMin) {
            l += t;
        }
    }

    int j = i + l * d;

    int first = min(i, j);
    int last  = max(i, j);

    // 3) Split
    int deltaNode = deltaIdx(first, last);

    int split = first;
    int step = last - first;

    do {
        step = (step + 1) >> 1;
        int newSplit = split + step;
        if (newSplit < last) {
            if (deltaIdx(first, newSplit) > deltaNode) {
                split = newSplit;
            }
        }
    } while (step > 1);

    // 4) Children
    int leftChild;
    if (split == first) leftChild = first;             // leaf
    else                leftChild = int(N) + split;    // internal (FIX)

    int rightChild;
    if (split + 1 == last) rightChild = last;               // leaf
    else                   rightChild = int(N) + split + 1; // internal

    int internalNode = int(N) + i;  // global node index
    int internalID   = i;           // internal-only index [0..N-2]

    if (i == 0) {
        nodeParent[internalNode] = -1;  // set as root
    }

    // Store children in the .w lanes (bitcast)
    nodeAabbMin[internalNode] = vec4(0.0, 0.0, 0.0, uintBitsToFloat(uint(leftChild)));
    nodeAabbMax[internalNode] = vec4(0.0, 0.0, 0.0, uintBitsToFloat(uint(rightChild)));

    nodeParent[leftChild]  = internalNode;
    nodeParent[rightChild] = internalNode;

}
