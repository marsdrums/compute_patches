// Find min/max over triangle geometry (for normalization)
#version 460
layout(local_size_x = 256) in;

struct minMax {
    vec3 mm;
    vec3 MM;
};

struct Tri {
    vec4 v0;
    vec4 v1;
    vec4 v2;
};

layout(std430, binding = 0) buffer buff_part   { Tri   tri[];  };
layout(std430, binding = 1) buffer buff_minMax { minMax mmMM[]; };

layout(binding = 2) uniform cfg {
    uint iteration;
    uint N;
};

shared minMax shammMM[gl_WorkGroupSize.x];

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationIndex;
    uint clampedGid = min(gid, N - 1u);

    if (iteration == 0u) {
        Tri t = tri[clampedGid];
        vec3 a = t.v0.xyz;
        vec3 b = t.v1.xyz;
        vec3 c = t.v2.xyz;

        vec3 tmin = min(a, min(b, c));
        vec3 tmax = max(a, max(b, c));

        shammMM[lid].mm = tmin;
        shammMM[lid].MM = tmax;
    } else {
        shammMM[lid] = mmMM[clampedGid];
    }

    barrier();

    // same reduction pattern as your original
    if (lid < 16) {
        uint base = lid * 16;
        for (uint i = 1u; i < 16u; i++) {
            uint id = base + i;
            shammMM[base].mm = min(shammMM[base].mm, shammMM[id].mm);
            shammMM[base].MM = max(shammMM[base].MM, shammMM[id].MM);
        }
    }
    barrier();

    if (lid == 0) {
        for (uint i = 1u; i < 16u; i++) {
            uint id = i * 16u;
            shammMM[0].mm = min(shammMM[0].mm, shammMM[id].mm);
            shammMM[0].MM = max(shammMM[0].MM, shammMM[id].MM);
        }
        mmMM[gl_WorkGroupID.x] = shammMM[0];
    }
}
