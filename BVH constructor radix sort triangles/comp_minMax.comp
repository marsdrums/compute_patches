// Find min/max over triangle geometry (for normalization)
#version 460
layout(local_size_x = 256) in;

struct minMax {
    vec3 mm;
    vec3 MM;
};

struct Tri {
    vec4 v0;
    vec4 v1;
    vec4 v2;
};

layout(std430, binding = 0) buffer buff_mesh   { vec4   v[];  };
layout(std430, binding = 1) buffer buff_minMax { minMax mmMM[]; };

layout(binding = 2) uniform cfg {
    uint iteration;
    uint N;
};

shared minMax shammMM[gl_WorkGroupSize.x];

Tri readVertices(uint id){
    id *= 3u;
    Tri t;
    t.v0 = v[id];
    t.v1 = v[id+1];
    t.v2 = v[id+2];
    return t;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationIndex;
    uint clampedGid = min(gid, N - 1u);

    if (iteration == 0u) {
        Tri t = readVertices(clampedGid);
        vec3 tmin = min(t.v0.xyz, min(t.v1.xyz, t.v2.xyz));
        vec3 tmax = max(t.v0.xyz, max(t.v1.xyz, t.v2.xyz));

        shammMM[lid].mm = tmin;
        shammMM[lid].MM = tmax;
    } else {
        shammMM[lid] = mmMM[clampedGid];
    }

    barrier();

    // same reduction pattern as your original
    if (lid < 16) {
        uint base = lid * 16;
        for (uint i = 1u; i < 16u; i++) {
            uint id = base + i;
            shammMM[base].mm = min(shammMM[base].mm, shammMM[id].mm);
            shammMM[base].MM = max(shammMM[base].MM, shammMM[id].MM);
        }
    }
    barrier();

    if (lid == 0) {
        for (uint i = 1u; i < 16u; i++) {
            uint id = i * 16u;
            shammMM[0].mm = min(shammMM[0].mm, shammMM[id].mm);
            shammMM[0].MM = max(shammMM[0].MM, shammMM[id].MM);
        }
        mmMM[gl_WorkGroupID.x] = shammMM[0];
    }
}
