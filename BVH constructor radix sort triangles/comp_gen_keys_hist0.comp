#version 460
layout(local_size_x = 128) in;

struct minMax { vec3 mm; vec3 MM; };

struct Key {
    uint morton;
    uint primID;
};

struct Tri {
    vec4 v0;
    vec4 v1;
    vec4 v2;
};

layout(std430, binding = 0) readonly buffer buff_part   { Tri   tri[];     };
layout(std430, binding = 1) readonly buffer buff_minMax { minMax mmMM[];   };
layout(std430, binding = 2) writeonly buffer buff_keys  { Key   key[];     };
layout(std430, binding = 3) writeonly buffer buff_groupHists { uint groupHists[]; };

layout(binding = 4) uniform cfg { uint N; };

shared minMax shammMM;
shared vec3  invDiff;
shared uint  shist[256];

uint expandBits(uint v) {
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint morton3D(vec3 x) {
    x = clamp(x * 1024.0, 0.0, 1023.0);
    uint xx = expandBits(uint(x.x));
    uint yy = expandBits(uint(x.y));
    uint zz = expandBits(uint(x.z));
    return (xx << 2) + (yy << 1) + zz;
}

void main() {
    uint lid = gl_LocalInvocationID.x;
    uint gid = gl_GlobalInvocationID.x;
    uint wg  = gl_WorkGroupID.x;

    if (lid == 0) {
        shammMM = mmMM[0];
        vec3 diff = shammMM.MM - shammMM.mm;
        invDiff = vec3(1.0) / max(vec3(1e-6), diff);
    }

    for (uint i = lid; i < 256u; i += gl_WorkGroupSize.x) shist[i] = 0u;
    barrier();

    if (gid < N) {
        Tri t = tri[gid];
        vec3 c = (t.v0.xyz + t.v1.xyz + t.v2.xyz) * (1.0 / 3.0);

        vec3 norm = (c - shammMM.mm) * invDiff;
        uint m = morton3D(norm);

        key[gid].morton = m;
        key[gid].primID = gid;

        uint bin = m & 0xFFu;
        atomicAdd(shist[bin], 1u);
    }

    barrier();

    for (uint i = lid; i < 256u; i += gl_WorkGroupSize.x) {
        groupHists[wg * 256u + i] = shist[i];
    }
}
