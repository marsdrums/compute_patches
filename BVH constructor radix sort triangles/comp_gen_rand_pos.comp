// Generate procedural triangles (replaces sphere center+radius)
#version 460
#extension GL_GOOGLE_include_directive : require
#include "c74.noise.funcs.glsl"

layout(local_size_x = 256) in;

struct Tri {
    vec4 v0;
    vec4 v1;
    vec4 v2;
};

layout(std430, binding = 0) buffer buff_part { Tri tri[]; };

layout(binding = 1) uniform cfg {
    float scale;
    float offset;
    float time;
    uint  N;
    float radius; // reuse as "triSize"
};

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= N) return;

    float p = float(gid) * scale + offset;

    // centroid (like your old sphere center)
    vec3 c;
    c.x = Normalize(fBmA(vec3(p,     0.0, time), 0.7, 2., 1, 3)) - 0.5;
    c.y = Normalize(fBmA(vec3(p,   100.0, time), 0.7, 2., 1, 3)) - 0.5;
    c.z = Normalize(fBmA(vec3(p, 10000.0, time), 0.7, 2., 1, 3)) - 0.5;

    // a pseudo-random normal to orient the triangle
    vec3 n;
    n.x = Normalize(fBmA(vec3(p,  42.0, time), 0.7, 2., 1, 3)) - 0.5;
    n.y = Normalize(fBmA(vec3(p, 142.0, time), 0.7, 2., 1, 3)) - 0.5;
    n.z = Normalize(fBmA(vec3(p, 242.0, time), 0.7, 2., 1, 3)) - 0.5;
    n = normalize(n);

    vec3 up = (abs(n.y) > 0.99) ? vec3(1,0,0) : vec3(0,1,0);
    vec3 t = normalize(cross(up, n));
    vec3 b = cross(n, t);

    float s = radius;               // triangle size
    float h = 0.86602540378;        // sqrt(3)/2

    // equilateral triangle in plane (t,b) around centroid c
    vec3 v0 = c + s * t;
    vec3 v1 = c + s * (-0.5 * t + h * b);
    vec3 v2 = c + s * (-0.5 * t - h * b);

    tri[gid].v0 = vec4(v0, 0.0);
    tri[gid].v1 = vec4(v1, 0.0);
    tri[gid].v2 = vec4(v2, 0.0);
}
