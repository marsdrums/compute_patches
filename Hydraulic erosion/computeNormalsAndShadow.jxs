#version 450

layout(std430, set = 0, binding = 0) buffer droplets {
    uint count;
    vec3 droplet[];
};

layout(set = 0, rgba32f, binding = 1) uniform image2D terrainImg;

layout(binding = 2) uniform Config {
    float frame;
};

layout(set = 0, rgba32f, binding = 3) uniform image2D norImg;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

const vec3 ligDir = normalize(vec3(1,-0.4,0.4));

//Random functions
uint wang_hash(inout uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float RandomFloat01(inout uint seed)
{
    return float(wang_hash(seed)) / 4294967296.0;
}

vec3 calcNormals(ivec2 gid, ivec2 size){

    float rDiff =   imageLoad(terrainImg, clamp(gid + ivec2(1,0), ivec2(0), size-1)).r - 
                    imageLoad(terrainImg, clamp(gid - ivec2(1,0), ivec2(0), size-1)).r;
                        
    float uDiff =   imageLoad(terrainImg, clamp(gid - ivec2(0,1), ivec2(0), size-1)).r - 
                    imageLoad(terrainImg, clamp(gid + ivec2(0,1), ivec2(0), size-1)).r;

    rDiff /= 2;
    uDiff /= 2;

    vec2 pixSize = vec2(1) / vec2(1024);
    vec3 r = normalize(vec3(pixSize.x, rDiff, 0));
    vec3 u = normalize(vec3(0, uDiff, pixSize.y));
    return normalize(cross(-r,u));
}

float calcShadow(vec3 ro, vec3 ligDir, vec2 size){
    float d = 0.01;
    for(int i = 0; i < 50; i++){

        vec3 p = ro + ligDir*d;
        ivec2 iuv = ivec2((p.xy*0.5 + 0.5)*size);
        if(iuv.x < 0 || iuv.y < 0 || iuv.x >= int(size.x) || iuv.y >= int(size.y)){
            return 1.0;
        }

        float h = imageLoad(terrainImg, iuv).r;
        if(h > p.z+0.01){
            return 0.0;
        }
        d += 0.02;
    }
    return 1.0;
}

float calcAO(ivec2 gid, ivec2 size, vec3 ro, vec3 N){

    uint seed = uint(gid.x) + uint(gid.y*size.x) + 999u;
    int numSectors = 12;
    float occ = float(numSectors);
    for(int i = 0; i < numSectors; i++){

        float randAngle = RandomFloat01(seed)*3.1415*2;
        vec2 rd = vec2(cos(randAngle), sin(randAngle));
        float highest = ro.z;
        vec3 tallestPoint = ro;
        for(float d = 0.01; d < 1.44; ){
            vec2 sampleUV = clamp(((ro.xy + rd*d)*0.5 + 0.5)*vec2(size), vec2(0.0), vec2(size-1));
            float sampledH = imageLoad(terrainImg, ivec2(sampleUV)).r;
            if(sampledH > highest){
                highest = sampledH;
                tallestPoint = vec3(ro.xy + rd*d, highest);
            }
            d *= 1.2;
        }
        vec3 freeDir = normalize(tallestPoint - ro);
        float cosine = max(0.0, dot(freeDir, N));
        occ -= cosine;
    }

    return occ / float(numSectors);
}

void main(){

    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(terrainImg));

    if(gid.x >= int(size.x) || gid.y >= int(size.y)) return;

    //if( (int(frame) % 60) != 0) return;

    float h = imageLoad(terrainImg, gid).r;
    vec3 ro;
    ro.xy = vec2(gid)/(size-1);
    ro.xy = ro.xy*2 - 1;
    ro.z = h;

    vec3 N = calcNormals(gid, ivec2(size));
    float sha = calcShadow(ro, ligDir, size);
    float ao = calcAO(gid, ivec2(size), ro, N);
    imageStore(terrainImg, gid, vec4(h,sha,ao,1));
    imageStore(norImg, gid, vec4(N, sha));

}