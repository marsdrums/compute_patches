// Based on https://www.firespark.de/resources/downloads/implementation%20of%20a%20methode%20for%20hydraulic%20erosion.pdf

#version 450

layout(std430, set = 0, binding = 0) buffer droplets {
    uint count;
    vec3 droplet[];
};

layout(set = 0, rgba32f, binding = 1) uniform image2D terrainImg;

layout(binding = 2) uniform ErosionParams {

    float borderSize;

    int maxLifetime;
    float inertia;
    float sedimentCapacityFactor;
    float minSedimentCapacity;
    float depositSpeed;
    float erodeSpeed;

    float evaporateSpeed;
    float gravity;
    float startSpeed;
    float startWater;
};

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

const float w[21] = float[](
    0.03076, 0.03076,
    0.04703, 0.04703,
    0.03076, 0.03076,

    0.06196, 0.08153, 0.06196,
    0.08153, 0.10870, 0.08153,
    0.06196, 0.08153, 0.06196,

    0.03076, 0.03076,
    0.04703, 0.04703,
    0.03076, 0.03076
);

const ivec2 off[21] = ivec2[](
    ivec2(-2,-1), ivec2(-1,-2),
    ivec2(-2, 0), ivec2( 0,-2),
    ivec2(-2, 1), ivec2( 1,-2),

    ivec2(-1,-1), ivec2(-1, 0), ivec2(-1, 1),
    ivec2( 0,-1), ivec2( 0, 0), ivec2( 0, 1),
    ivec2( 1,-1), ivec2( 1, 0), ivec2( 1, 1),

    ivec2( 2,-1), ivec2( 1, 2),
    ivec2( 2, 0), ivec2( 0, 2),
    ivec2( 2, 1), ivec2(-1, 2)
);

vec3 CalculateHeightAndGradient (vec2 pos) {

    vec2 coord = floor(pos);
    float x = fract(pos.x); 
    float y = fract(pos.y); 
    float invX = 1 - x;
    float invY = 1 - y;

    vec2 limit = vec2(imageSize(terrainImg)) - 1;

    ivec2 c  = ivec2(clamp(coord,                vec2(0.0), limit));
    ivec2 cE = ivec2(clamp(coord + vec2(1,0),    vec2(0.0), limit));
    ivec2 cS = ivec2(clamp(coord + vec2(0,1),    vec2(0.0), limit));
    ivec2 cSE= ivec2(clamp(coord + vec2(1,1),    vec2(0.0), limit));

    float hNW = imageLoad(terrainImg, c ).r;
    float hNE = imageLoad(terrainImg, cE).r;
    float hSW = imageLoad(terrainImg, cS).r;
    float hSE = imageLoad(terrainImg, cSE).r;

    vec2 gradient = vec2(   mix(hNE - hNW, hSE - hSW, y),
                            mix(hSW - hNW, hSE - hNE, x)
                        );

    float height =  hNW * invX * invY + 
                    hNE * x * invY + 
                    hSW * invX * y + 
                    hSE * x * y;

    return vec3(gradient,height);
}

void main(){

    uint gid = gl_GlobalInvocationID.x;
    vec2 mapSize = vec2(imageSize(terrainImg));

    if (gid >= 1024) return;

    vec2 pos = droplet[gid].xy;
    vec2 dir = vec2(0.0);
    float speed = startSpeed;
    float water = startWater;
    float sediment = 0;

    for(int lifetime = maxLifetime; lifetime > 0; lifetime--) {

        ivec2 cell = ivec2(floor(pos));
        float x = fract(pos.x);
        float y = fract(pos.y);
        float invX = 1 - x;
        float invY = 1 - y;

        // Calculate droplet's height and direction of flow with bilinear interpolation of surrounding heights
        vec3 heightAndGradient = CalculateHeightAndGradient(pos);

        // Update the droplet's direction and position (move position 1 unit regardless of speed)
        dir = mix(-heightAndGradient.xy, dir, inertia);

        // Normalize direction
        float len = max(0.01,length(dir));
        dir /= len;
        pos += dir;

        // Stop simulating droplet if it's not moving or has flowed over edge of map
        if ((dir.x == 0 && dir.y == 0) || 
            pos.x < borderSize || 
            pos.x >= (mapSize.x - borderSize) || 
            pos.y < borderSize || 
            pos.y >= (mapSize.y - borderSize)) {
            break;
        }

        // Find the droplet's new height and calculate the deltaHeight
        float newHeight = CalculateHeightAndGradient(pos).z;
        float deltaHeight = newHeight - heightAndGradient.z; 

        // Calculate the droplet's sediment capacity (higher when moving fast down a slope and contains lots of water)
        float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);

        // If carrying more sediment than capacity, or if flowing uphill:
        if (sediment > sedimentCapacity || deltaHeight > 0) {
            // If moving uphill (deltaHeight > 0) try fill up to the current height, otherwise deposit a fraction of the excess sediment
            float amountToDeposit = (deltaHeight > 0) ? min(deltaHeight, sediment) : (sediment - sedimentCapacity) * depositSpeed;
            sediment -= amountToDeposit;

            // Add the sediment to the four nodes of the current cell using bilinear interpolation
            // Deposition is not distributed over a radius (like erosion) so that it can fill small pits
            ivec2 iuv;
            float val;

            iuv = cell;
            val = imageLoad(terrainImg, iuv).r;
            val += amountToDeposit * invX * invY;
            imageStore(terrainImg, iuv, vec4(val));

            iuv = cell + ivec2(1,0);
            val = imageLoad(terrainImg, iuv).r;
            val += amountToDeposit * x * invY;
            imageStore(terrainImg, iuv, vec4(val));

            iuv = cell + ivec2(0,1);
            val = imageLoad(terrainImg, iuv).r;
            val +=  amountToDeposit * invX * y;
            imageStore(terrainImg, iuv, vec4(val));

            iuv = cell + ivec2(1,1);
            val = imageLoad(terrainImg, iuv).r;
            val += amountToDeposit * x * y;
            imageStore(terrainImg, iuv, vec4(val));
        }  
        else {
            // Erode a fraction of the droplet's current carry capacity.
            // Clamp the erosion to the change in height so that it doesn't dig a hole in the terrain behind the droplet
            float amountToErode = min ((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);

            for(int k = 0; k < 21; k++){
                ivec2 erodeUV = cell + off[k];
                erodeUV = clamp(erodeUV, ivec2(0), ivec2(mapSize - 1));
                float weightedErodeAmount = amountToErode * w[k];
                float currH = imageLoad(terrainImg, erodeUV).r;
                float deltaSediment = currH < weightedErodeAmount ? currH : weightedErodeAmount;
                float newH = currH - deltaSediment;
                imageStore(terrainImg, erodeUV, vec4(newH));
                sediment += deltaSediment; 
            }
        }
        // Update droplet's speed and water content
        speed = sqrt(max(0,speed * speed + deltaHeight * gravity));
        water *= (1 - evaporateSpeed);
    }
}