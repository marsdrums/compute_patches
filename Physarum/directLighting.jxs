#version 450

layout(set = 0, rgba32f, binding = 0) uniform image3D rendImg;
layout(set = 0, rgba32f, binding = 1) uniform image2D norHeightImg;
layout(set = 0, rgba32f, binding = 2) uniform image2D stbnImg;
layout(set = 0, rgba32f, binding = 3) uniform writeonly image2D albedoImg;

layout(binding = 4) uniform Cfg {
    float senseAngle;
    float turnAngle;
    float senseDist;
    float speed;
    uint frame;
    float maxPheromone;
    float evaporate;
};

layout(binding = 5) uniform slice {
    int readSlice;
    int writeSlice;
}pc;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;


//___ RNG functions
uint wang_hash(inout uint seed){

    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float RandomFloat01(inout uint seed){

    return float(wang_hash(seed)) / 4294967296.0;
}

vec3 RandomUnitVector(inout uint seed){

    float z = RandomFloat01(seed) * 2.0f - 1.0f;
    float a = RandomFloat01(seed) * 6.28318530718;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

uint getRandSeed(uint idx){ 
    return  idx + frame*8271u; 
}


float sampleTerrain(ivec2 uv, ivec2 size){

    uv = clamp(uv, ivec2(0), size-1);
	return imageLoad(rendImg, ivec3(uv, pc.readSlice)).a;
}

float traceShadow(vec3 ro, vec3 rd, ivec2 size, uint seed){

    float d = 2;
    //rd = normalize(rd + RandomUnitVector(seed)*0.01);
    vec3 p;
    float h;
    ivec2 iuv;
    float sha = 1.0;
    for(int i = 0; i < 40; i++){
        p = ro + rd*d;
        iuv = ivec2(p.xy);
        if(iuv.x < 0 || iuv.y < 0 || iuv.x >= size.x || iuv.y >= size.y){
            return sha;
        }
        float diff =  p.z - imageLoad(rendImg, ivec3(iuv, pc.readSlice)).a;

        if(diff < 0.0001) return 0.0;

        sha = min( sha, 4*diff/d );
        if(sha <= 0){
            return 0.0;
        }
        d += mix(4, 20, RandomFloat01(seed));
    }
    return sha;
}

void main(){

    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(rendImg).xy;

    uint seed = getRandSeed(gid.x + gid.y*uint(size.x) + 9999u);

    float h = imageLoad(rendImg, ivec3(gid, pc.readSlice)).a;

    if (gid.x >= size.x || gid.y >= size.y) return;

    float l = sampleTerrain(gid - ivec2(1,0), size);
    float r = sampleTerrain(gid + ivec2(1,0), size);
    float d = sampleTerrain(gid - ivec2(0,1), size);
    float u = sampleTerrain(gid + ivec2(0,1), size);

    vec3 right = normalize(vec3(2,0,r-l));
    vec3 up = normalize(vec3(0,2,u-d));
    vec3 N = normalize(cross(right, up));

    imageStore(norHeightImg, gid, vec4(N, h));

    ivec2 wrappedGid = gid % ivec2(64);
    int tile = int(frame) % 64;
    ivec2 tileOffset = ivec2(tile % 8, floor(tile/8)) * 64;
    ivec2 stbnGid = wrappedGid + tileOffset;
    vec3 stbn = imageLoad(stbnImg, stbnGid).xyz*2 - 1;

    vec3 ro = vec3(gid.x, gid.y, h);
    vec3 res = vec3(0.0);
    vec3 alb = 0.4 + 0.3*cos((1 - h/60)*vec3(1,2,3));
    
    imageStore(albedoImg, gid, vec4(alb, 1.0));

    {
        vec3 ligDir = normalize(vec3(1,-4,9.4) + stbn*0.2);
        vec3 ligCol = vec3(3,2.5,2)*1;
        float diff = max(0.0, dot(ligDir, N));
        float sha = 1.0;
        if(diff > 0){
            sha = traceShadow(ro, ligDir, size, seed);
        }
        res += ligCol * diff * sha;
    }

    res *= alb;
    //res += h > 280 ? vec3(6) : vec3(0);
    imageStore(rendImg, ivec3(gid, pc.writeSlice), vec4(res, h));
}