#version 450

struct Agent {
    vec2 pos;
    vec2 vel;
    float angle;
};

layout(std430, set = 0, binding = 0) buffer agentsBuff {
    uint count;
    Agent agents[];
};

layout(set = 0, r32f, binding = 1) uniform image2D rendImg;
layout(set = 0, rgba32f, binding = 2) uniform image2D shadedImg;
layout(set = 0, rgba32f, binding = 3) uniform image2D norHeightImg;

layout(binding = 4) uniform Cfg {
    float senseAngle;
    float turnAngle;
    float senseDist;
    float speed;
    uint frame;
    float maxPheromone;
    float evaporate;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;


//___ RNG functions
uint wang_hash(inout uint seed){

    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float RandomFloat01(inout uint seed){

    return float(wang_hash(seed)) / 4294967296.0;
}

vec3 RandomUnitVector(inout uint seed){

    float z = RandomFloat01(seed) * 2.0f - 1.0f;
    float a = RandomFloat01(seed) * 6.28318530718;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

uint getRandSeed(uint idx){ 
    return  idx + frame*count; 
}

vec3 calcIndirectLight(ivec2 gid, ivec2 size, vec3 ro, vec3 N, uint seed){

    int numSectors = 6;
    vec3 res = vec3(0.0);
    float occ = float(numSectors);
    float count = 0.0;
    for(int i = 0; i < numSectors; i++){

        float randAngle = RandomFloat01(seed)*3.1415*2;
        vec2 rd = vec2(cos(randAngle), sin(randAngle));
        float largestCosine = 0.0;
        for(float d = mix(1.8, 3., RandomFloat01(seed)); d < 400; ){
            vec2 sampleUV = clamp(ro.xy + rd*d, vec2(0.0), vec2(size-1));
            float sampledH = imageLoad(rendImg, ivec2(sampleUV)).r;
            vec3 p = vec3(sampleUV, sampledH);
            vec3 dir = normalize(p - ro);
            float cosine = dot(dir, N);
            if(cosine > largestCosine){
                largestCosine = cosine;
                res += cosine * imageLoad(shadedImg, ivec2(sampleUV)).rgb;
            }
            d *= 1.2;
            count += 1.0;
        }
    }

    return res / count;
}

void main(){

    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(rendImg).xy;

    uint seed = getRandSeed(gid.x + gid.y*uint(size.x) + 7777u);

    if (gid.x >= size.x || gid.y >= size.y) return;

    vec4 lookup = imageLoad(norHeightImg, gid);
    vec3 N = lookup.xyz;
    float h = lookup.w;

    vec3 ro = vec3(gid.x, gid.y, h);
    vec3 ind = calcIndirectLight(gid, ivec2(size), ro, N, seed);
    vec3 alb = vec3(0.8);//0.5 + 0.5*cos((1 - h/30)*vec3(1,2,3));

    ind *= alb;
    vec3 dir = imageLoad(shadedImg, gid).rgb;
    imageStore(shadedImg, gid, vec4(dir + ind, 1.0));
}