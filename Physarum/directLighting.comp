#version 450

// ----------------------------------------------------------------------------
// Inputs / Outputs
// ----------------------------------------------------------------------------

// 3D field image:
// - alpha (w) stores terrain height
// - RGB (xyz) stores shaded color output for this pass (written to writeSlice)
layout(set = 0, rgba32f, binding = 0) uniform image3D rendImg;

// 2D output: normal (xyz) + height (w)
layout(set = 0, rgba32f, binding = 1) uniform image2D norHeightImg;

// STBN (spatiotemporal blue-noise) texture used to jitter lighting / ray steps.
// Declared as image2D for load access (not sampled, no filtering).
layout(set = 0, rgba32f, binding = 2) uniform image2D stbnImg;

// 2D output albedo (base color) (write-only)
layout(set = 0, rgba32f, binding = 3) uniform writeonly image2D albedoImg;

// Per-frame configuration
layout(binding = 4) uniform Cfg {
    uint frame;
};

// Slice routing for the 3D image
layout(binding = 5) uniform slice {
    int readSlice;   // read heights (and maybe previous color) from this slice
    int writeSlice;  // write shaded RGB + original height into this slice
} pc;

// 16x16 threads per workgroup
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ----------------------------------------------------------------------------
// RNG (hash-based, cheap)
// ----------------------------------------------------------------------------

// Wang hash: mutates the seed and returns a pseudo-random uint.
uint wang_hash(inout uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed ^= (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed ^= (seed >> 15u);
    return seed;
}

// Uniform float in [0, 1)
float rand01(inout uint seed) {
    return float(wang_hash(seed)) / 4294967296.0; // 2^32
}

// Frame-varying seed. The constant just helps decorrelate from other passes.
uint makeSeed(uint linearIdx) {
    return linearIdx + frame * 8271u;
}

// ----------------------------------------------------------------------------
// Terrain helpers
// ----------------------------------------------------------------------------

// Load terrain height (alpha channel) at uv, clamped to image bounds.
float loadHeightClamped(ivec2 uv, ivec2 size) {
    uv = clamp(uv, ivec2(0), size - ivec2(1));
    return imageLoad(rendImg, ivec3(uv, pc.readSlice)).a;
}

// Trace a cheap shadow ray over the heightfield.
// ro = ray origin in "world" coordinates (x,y in pixel units, z = height)
// rd = ray direction (assumed normalized-ish)
// Returns a shadow factor in [0,1], where 0 = fully occluded, 1 = fully lit.
float traceShadow(vec3 ro, vec3 rd, ivec2 size, inout uint seed) {

    // Start a bit away from the surface to reduce self-shadowing.
    float t = 2.0;

    // Soft shadow accumulator (starts fully lit)
    float sha = 1.0;

    // Fixed number of steps: cheap and stable on GPU.
    for (int i = 0; i < 30; ++i) {
        vec3 p = ro + rd * t;
        ivec2 iuv = ivec2(p.xy);

        // If ray leaves the map, keep current shadow estimate.
        if (iuv.x < 0 || iuv.y < 0 || iuv.x >= size.x || iuv.y >= size.y) {
            return sha;
        }

        // Compare ray height against terrain height.
        float terrainH = imageLoad(rendImg, ivec3(iuv, pc.readSlice)).a;
        float diff = p.z - terrainH;

        // Hit terrain (occluded). Tiny epsilon avoids acne but is still harsh.
        if (diff < 0.0001) return 0.0;

        // "Soft shadow" style attenuation: smaller diff relative to t => darker.
        // (This is a heuristic, not physically based.)
        sha = min(sha, 4.0 * diff / t);
        if (sha <= 0.0) return 0.0;

        // Advance ray with randomized step length to reduce banding.
        // mix(4,20,x) chooses step in [4,20).
        t += mix(4.0, 20.0, rand01(seed));
    }

    return sha;
}

// ----------------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------------

void main() {
    ivec2 gid  = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(rendImg).xy;

    // Bounds guard (important if dispatch covers padded size)
    if (gid.x >= size.x || gid.y >= size.y) return;

    // Build a stable linear index for RNG
    uint linearIdx = uint(gid.x) + uint(gid.y) * uint(size.x);
    uint seed = makeSeed(linearIdx + 9999u);

    // Height at this pixel (stored in alpha)
    float h = imageLoad(rendImg, ivec3(gid, pc.readSlice)).a;

    // -------------------------------------------------------------------------
    // Compute a normal from height differences (finite differences).
    // l/r/d/u are neighboring heights; z scale is a chosen constant (2.0).
    // -------------------------------------------------------------------------
    float hl = loadHeightClamped(gid + ivec2(-1,  0), size);
    float hr = loadHeightClamped(gid + ivec2( 1,  0), size);
    float hd = loadHeightClamped(gid + ivec2( 0, -1), size);
    float hu = loadHeightClamped(gid + ivec2( 0,  1), size);

    vec3 N = normalize(vec3(hl - hr, hd - hu, 2.0));

    // Store normal+height for later passes (e.g., display or post)
    imageStore(norHeightImg, gid, vec4(N, h));

    // -------------------------------------------------------------------------
    // STBN lookup: 64x64 tiles, cycling through an 8x8 atlas of tiles (4096x4096
    // worth of unique blue-noise if packed that way).
    //
    // wrappedGid: 0..63 local position inside a 64x64 tile
    // tile:       which tile to use this frame (0..63)
    // tileOffset: tile origin in the atlas (8 columns x 8 rows of tiles)
    // -------------------------------------------------------------------------
    ivec2 wrappedGid = gid % ivec2(64);

    int tile = int(frame % 64u); // cycle 0..63
    ivec2 tileOffset = ivec2(tile % 8, tile / 8) * 64;

    ivec2 stbnUV = wrappedGid + tileOffset;

    // Convert from [0,1] to [-1,1] for jitter vector
    vec3 stbn = imageLoad(stbnImg, stbnUV).xyz * 2.0 - 1.0;

    // -------------------------------------------------------------------------
    // Base material (albedo) as a simple height-based cosine palette.
    // h/60 controls banding frequency and range.
    // -------------------------------------------------------------------------
    vec3 alb = 0.4 + 0.3 * cos((1.0 - h / 60.0) * vec3(1.0, 2.0, 3.0));

    // Write albedo out separately (useful for later shading)
    imageStore(albedoImg, gid, vec4(alb, 1.0));

    // -------------------------------------------------------------------------
    // Lighting
    // -------------------------------------------------------------------------

    // Ray origin at the terrain point in "world" coordinates
    vec3 ro = vec3(float(gid.x), float(gid.y), h);

    // Directional light, jittered slightly using blue-noise to break up artifacts
    vec3 ligDir = normalize(vec3(1.0, -4.0, 9.4) + stbn * 0.2);

    // Light color/intensity (arbitrary units)
    vec3 ligCol = vec3(3.0, 2.5, 2.0);

    // Lambert diffuse
    float ndotl = max(0.0, dot(ligDir, N));

    // Shadow factor (only trace if the surface faces the light)
    float sha = 1.0;
    if (ndotl > 0.0) {
        sha = traceShadow(ro, ligDir, size, seed);
    }

    vec3 res = ligCol * ndotl * sha * alb;

    // -------------------------------------------------------------------------
    // Output: store shaded RGB + original height alpha into the destination slice
    // -------------------------------------------------------------------------
    imageStore(rendImg, ivec3(gid, pc.writeSlice), vec4(res, h));
}
