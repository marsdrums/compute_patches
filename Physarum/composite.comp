#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, rgba32f, binding = 0) uniform readonly image3D rendImg;
layout(set = 0, rgba32f, binding = 1) uniform readonly image3D bouncesImg;
layout(set = 0, rgba32f, binding = 2) uniform readonly image2D stbnImg;
layout(set = 0, rgba32f, binding = 3) uniform readonly image2D albedoImg;
layout(set = 0, rgba32f, binding = 4) uniform writeonly image2D indirectImg;
layout(set = 0, rgba32f, binding = 5) uniform writeonly image2D directImg;

layout(binding = 6) uniform slice {
    int readSlice;
    int writeSlice;
}pc;

layout(binding = 7) uniform frameParam {
    int frame;
};

void main() {

    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    vec2 fgid = vec2(gid);
    ivec2 size = imageSize(indirectImg).xy;

    if(gid.x >= size.x || gid.y >= size.y) return;

    vec2 offset[4] = vec2[](    vec2(0,0), 
                                vec2(1,0), 
                                vec2(0,1), 
                                vec2(1,1));

    ivec2 wrappedGid = gid % ivec2(64);
    int tile = frame % 64;
    ivec2 tileOffset = ivec2(tile % 8, floor(tile/8)) * 64;
    ivec2 stbnGid = wrappedGid + tileOffset;
    vec2 stbn = imageLoad(stbnImg, stbnGid).xy*2 - 1;

    ivec2 halfGid = ivec2(floor((fgid + stbn*2)*0.5));

    vec3 ind =  imageLoad(bouncesImg, ivec3(halfGid, 0)).xyz;
    ind +=      imageLoad(bouncesImg, ivec3(halfGid, 1)).xyz;
    ind +=      imageLoad(bouncesImg, ivec3(halfGid, 2)).xyz;
    ind +=      imageLoad(bouncesImg, ivec3(halfGid, 3)).xyz;

    vec3 alb = imageLoad(albedoImg, halfGid).rgb;

    //float h = imageLoad(bouncesImg, ivec3(halfGid, 0)).w;
    //vec3 alb = 0.4 + 0.3*cos((1 - h/60)*vec3(1,2,3));
    
    //ind /= alb; //demodulate by albedo

    //imageStore(rendImg, ivec3(gid, 0), vec4(dir + ind, 1.0));
    imageStore(indirectImg, gid, vec4(ind, 1.0));
    imageStore(directImg, gid, imageLoad(rendImg, ivec3(gid, pc.readSlice)));
}