#version 460
layout(local_size_x = 256) in;

struct minMax{
    vec3 mm;
    vec3 MM;
};

struct Key{
    uint morton;
    uint primID;
};

layout(std430,  binding = 0) buffer buff_part { vec4 pr[]; };
layout(std430,  binding = 1) buffer buff_minMax { minMax mmMM[]; };
layout(std430,  binding = 2) buffer buff_normPos { Key key[]; };
layout(         binding = 3) uniform cfg{ uint N; };

shared minMax shammMM;
shared vec3 invDiff;

//Morton codes function from:
// https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu/

// Expands a 10-bit integer into 30 bits
// by inserting 2 zeros after each bit.
uint expandBits(uint v)
{
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

// Calculates a 30-bit Morton code for the
// given 3D point located within the unit cube [0,1].
uint morton3D(vec3 v)
{
    v = clamp(v*1024.0, vec3(0.0), vec3(1023.0));
    uint xx = expandBits(uint(v.x));
    uint yy = expandBits(uint(v.y));
    uint zz = expandBits(uint(v.z));
    return xx * 4 + yy * 2 + zz;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;

    if(gl_LocalInvocationIndex == 0){
        shammMM = mmMM[0];
        vec3 diff = shammMM.MM - shammMM.mm;
        invDiff = vec3(1.0) / max(vec3(1e-6), diff);
    }
    barrier();

    if(gid >= N) return;

    vec4 pos_radius = pr[gid];
    vec3 norm = (pos_radius.xyz - shammMM.mm) * invDiff;

    key[gid].morton = morton3D(norm);
    key[gid].primID = gid;
}