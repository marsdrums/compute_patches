//Ray trace
#version 460
#extension GL_GOOGLE_include_directive : require
#include "c74.noise.funcs.glsl"

layout(std430, binding = 0) readonly buffer buff_part        { vec4 pr[]; };
layout(std430, binding = 1) readonly buffer buff_nodeChild   { ivec2 nodeChild[]; };
layout(std430, binding = 2) readonly buffer buff_nodeAabbMin { vec4 nodeAabbMin[]; };
layout(std430, binding = 3) readonly buffer buff_nodeAabbMax { vec4 nodeAabbMax[]; };
layout(std430, binding = 4) readonly buffer buff_nodePrim    { int  nodePrim[]; };
layout(rgba32f,binding = 5) uniform writeonly image2D img_res;

layout(binding = 6) uniform camParams {
    vec3 pos;
    vec3 dir;
} cam;

layout(binding = 7) uniform cfg {
    uint N;
    vec2 fsize;
    ivec2 size;
    vec2 invSize;
    float invRatio;
};

shared mat3 cameraBasis; // columns: right, up, forward

struct ray {
    vec3 origin;
    vec3 direction; // should be normalized
    vec3 invDir;
};

layout(local_size_x = 16, local_size_y = 16) in;

bool intersectAABB_Ray(in ray r, vec3 bmin, vec3 bmax, float tMax, out float tNear){

    vec3 t0 = (bmin - r.origin) * r.invDir;
    vec3 t1 = (bmax - r.origin) * r.invDir;
    vec3 tsm = min(t0, t1);
    vec3 tbg = max(t0, t1);

    float tn = max(max(tsm.x, tsm.y), tsm.z);
    float tf = min(min(tbg.x, tbg.y), tbg.z);

    tNear = tn;
    return (tf >= max(tn, 0.0)) && (tn <= tMax);
}

bool intersectSphere(in ray r, vec4 sphere, inout float bestT){

    vec3 oc = r.origin - sphere.xyz;
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - sphere.w * sphere.w;
    float h = b*b - c;
    if (h < 0.0) return false;

    h = sqrt(h);
    float t = -b - h;
    if (t < 0.0) t = -b + h;
    if (t < 0.0) return false;

    if (t < bestT) {
        bestT = t;
        return true;
    }
    return false;
}

float shadowRay(in ray r){

    int root = int(N); 

    const int STACK_CAP = 32;
    int   stackNode[STACK_CAP];
    float stackNear[STACK_CAP];
    int sp = 0;

    float bestT = 1e30;
    int bestPrim = -1;

    int node = root;
    float nodeNear = 0.0;

    for (;;) {
        // Descend until we run out of nodes on this path
        for (;;) {

            float tNear;
            if (!intersectAABB_Ray(r, nodeAabbMin[node].xyz, nodeAabbMax[node].xyz, bestT, tNear))
                break;

            ivec2 ch = nodeChild[node];
            bool isLeaf = (ch.x < 0 && ch.y < 0);

            if (isLeaf) {
                int primID = nodePrim[node];
                if (primID >= 0) {
                    float t = bestT;
                    if (intersectSphere(r, pr[primID], t)) {
                        return 0.0;
                    }
                }
                break;
            }

            int c0 = ch.x;
            int c1 = ch.y;

            float t0, t1;
            bool h0 = intersectAABB_Ray(r, nodeAabbMin[c0].xyz, nodeAabbMax[c0].xyz, bestT, t0);
            bool h1 = intersectAABB_Ray(r, nodeAabbMin[c1].xyz, nodeAabbMax[c1].xyz, bestT, t1);

            if (h0 && h1) {
                // choose near/far
                int nearNode, farNode;
                float nearT, farT;
                if (t0 < t1) {
                    nearNode = c0; nearT = t0;
                    farNode  = c1; farT  = t1;
                } else {
                    nearNode = c1; nearT = t1;
                    farNode  = c0; farT  = t0;
                }

                // push far, descend near immediately
                if (sp < STACK_CAP) {
                    stackNode[sp] = farNode;
                    stackNear[sp] = farT;
                    sp++;
                }
                node = nearNode;
                nodeNear = nearT;
                continue;
            }

            if (h0) {
                node = c0;
                nodeNear = t0;
                continue;
            }

            if (h1) {
                node = c1;
                nodeNear = t1;
                continue;
            }

            break; // neither child hit
        }

        // Pop next deferred node
        if (sp == 0) break;
        sp--;
        node = stackNode[sp];
        nodeNear = stackNear[sp];
    }   
    return 1.0; 
}

void rayTrace(in ray r, out int bestPrim, out float bestT){

    int root = int(N); 

    const int STACK_CAP = 32;
    int   stackNode[STACK_CAP];
    float stackNear[STACK_CAP];
    int sp = 0;

    bestT = 1e30;
    bestPrim = -1;

    int node = root;
    float nodeNear = 0.0;

    for (;;) {
        // Descend until we run out of nodes on this path
        for (;;) {
            if (nodeNear > bestT) break;

            float tNear;
            if (!intersectAABB_Ray(r, nodeAabbMin[node].xyz, nodeAabbMax[node].xyz, bestT, tNear))
                break;

            ivec2 ch = nodeChild[node];
            bool isLeaf = (ch.x < 0 && ch.y < 0);

            if (isLeaf) {
                int primID = nodePrim[node];
                if (primID >= 0) {
                    float t = bestT;
                    if (intersectSphere(r, pr[primID], t)) {
                        bestT = t;
                        bestPrim = primID;
                    }
                }
                break;
            }

            int c0 = ch.x;
            int c1 = ch.y;

            float t0, t1;
            bool h0 = intersectAABB_Ray(r, nodeAabbMin[c0].xyz, nodeAabbMax[c0].xyz, bestT, t0);
            bool h1 = intersectAABB_Ray(r, nodeAabbMin[c1].xyz, nodeAabbMax[c1].xyz, bestT, t1);

            if (h0 && h1) {
                // choose near/far
                int nearNode, farNode;
                float nearT, farT;
                if (t0 < t1) {
                    nearNode = c0; nearT = t0;
                    farNode  = c1; farT  = t1;
                } else {
                    nearNode = c1; nearT = t1;
                    farNode  = c0; farT  = t0;
                }

                // push far, descend near immediately
                if (sp < STACK_CAP) {
                    stackNode[sp] = farNode;
                    stackNear[sp] = farT;
                    sp++;
                }
                node = nearNode;
                nodeNear = nearT;
                continue;
            }

            if (h0) {
                node = c0;
                nodeNear = t0;
                continue;
            }

            if (h1) {
                node = c1;
                nodeNear = t1;
                continue;
            }

            break; // neither child hit
        }

        // Pop next deferred node
        if (sp == 0) break;
        sp--;
        node = stackNode[sp];
        nodeNear = stackNear[sp];
    }
}

uint getSeed(){
    return gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*uint(size.x) + 999u;
}

void main() {

    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    uint  lid   = gl_LocalInvocationIndex;

    // Compute camera basis once per workgroup.
    if (lid == 0u) {
        //*** move all this CPU side
        vec3 fwd = normalize(cam.dir);
        vec3 worldUp = (abs(fwd.y) > 0.99) ? vec3(1,0,0) : vec3(0,1,0);
        vec3 right = normalize(cross(fwd, worldUp));
        vec3 up    = normalize(cross(right, fwd));
        cameraBasis = mat3(right, up, fwd);
    }
    barrier();

    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 ndc = 2.0 * vec2(pixel)*invSize - 1.0;
    ndc.y *= invRatio;
    ndc.y *= -1;

    // Build primary ray direction in camera space then transform to world.
    vec3 dirCam = normalize(vec3(ndc, 1.0));
    vec3 dirWorld = dirCam.x * cameraBasis[0] + dirCam.y * cameraBasis[1] + dirCam.z * cameraBasis[2];

    ray r;
    r.origin = cam.pos;
    r.direction = dirWorld;
    vec3 s = sign(dirWorld);
    vec3 a = max(abs(dirWorld), vec3(1e-8));
    r.invDir = s / a;

    int bestPrim;
    float bestT;
    rayTrace(r, bestPrim, bestT);

    if(bestPrim < 0){
        imageStore(img_res, pixel, vec4(1.0));
        return;
    }

    vec4 sphere = pr[bestPrim];
    vec3 p = r.origin + r.direction*bestT;
    vec3 N = (p - sphere.xyz) / sphere.w;
    r.origin = p + N*0.0001;
    vec3 alb = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + float(bestPrim) * 0.035);

    vec3 res = vec3(0.0);
/*
    {
        vec3 ligPos = vec3(2,-1,0.4);
        vec3 ligDir = normalize(ligPos - p);
        vec3 ligCol = vec3(6,4,2);
        float diff = max(0.0, dot(N, ligDir));
        float shadow = 1.0;
        if(diff > 0.0){
            r.direction = ligDir;
            s = sign(ligDir);
            a = max(abs(ligDir), vec3(1e-8));
            r.invDir = s / a;
            shadow = shadowRay(r);
        }       
        res += alb * diff*shadow * ligCol;
    }

    {
        vec3 ligPos = vec3(-1,-1.4,0.8);
        vec3 ligDir = normalize(ligPos - p);
        vec3 ligCol = vec3(2,4,8);
        float diff = max(0.0, dot(N, ligDir));
        float shadow = 1.0;
        if(diff > 0.0){
            r.direction = ligDir;
            s = sign(ligDir);
            a = max(abs(ligDir), vec3(1e-8));
            r.invDir = s / a;
            shadow = shadowRay(r);
        }       
        res += alb * diff*shadow * ligCol;
    }
*/
    float ao = 0.0;
    uint seed = getSeed();
    for(int i = 0; i < 8; i++){
        vec3 rd = normalize(N + randomUnitVector3(seed));
        r.direction = rd;
        s = sign(rd);
        a = max(abs(rd), vec3(1e-8));
        r.invDir = s / a;
        ao += shadowRay(r);

    }
    ao /= 8.0;

    // simple ID-based color
    //res /= res + 1;
    res = vec3(ao);
    imageStore(img_res, pixel, vec4(pow(res, vec3(0.45454545)), 1.0));

}