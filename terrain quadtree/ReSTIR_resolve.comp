// default compute shader
/*
Compute surface position from pixel + height (img_norH.a) and normal from img_norH.rgb.

Draw K random light indices.

For each candidate light:

    compute f(x,y)
    compute RIS weight w = f/p
    do reservoir update (stochastic replacement)

Store reservoir.
*/
#version 460
#extension GL_GOOGLE_include_directive : require
#include "c74.noise.funcs.glsl"

struct Light{
    vec3 pos;   
    vec3 col;  
};

struct Geom{
    vec3 pos;
    vec3 nor;
    vec3 alb;
};

struct Reservoir{
    uint Y; // index of most important light
    float W_y; // light weight
    float W_sum; // sum of all weights for all lights processed
    float M; // number of lights processed for this reservoir
};

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform readonly image2D img_norH;
layout(rgba32f, binding = 1) uniform readonly image2D img_alb;
layout(rgba32f, binding = 2) uniform readonly image2D img_pos;
layout(rgba32f, binding = 3) uniform writeonly image2D img_raw_dir;
layout(rgba32f, binding = 4) uniform image2D img_reservoir;
layout(std430,  binding = 5) buffer buff_lights { uint light_count; Light lights[]; };
layout(         binding = 6) uniform cfg{ uint frame; int readOffset; int writeOffset; };

shared ivec2 size;
shared vec2 fsize;
shared float ratio;

uint getSeed(ivec2 gid){ return uint(gid.x + gid.y*size.x) + frame*uint(size.x*size.y) + 333u; }

void getImageSize(){
    if(gl_LocalInvocationIndex == 0){
        size = imageSize(img_norH);
        fsize = vec2(size);
        ratio = float(size.x) / float(size.y);
    }
    barrier();
}

Geom getGeom(ivec2 gid){

    Geom g;
    g.nor = imageLoad(img_norH, gid).xyz;
    g.pos = imageLoad(img_pos, gid).xyz;
    g.alb = imageLoad(img_alb, gid).rgb;
    return g;
}

 
bool UpdateReservoir(inout Reservoir r, uint X, float w, float c, inout uint seed)
{
    r.W_sum += w;
    r.M += c;
 
    if ( RandomFloat01(seed) < w / r.W_sum  ){
        r.Y = X;
        return true;
    }
 
    return false;
}

bool IsReservoirValid(Reservoir r)
{
    return (r.M > 0.0) && (r.W_sum > 0.0) && (r.Y < light_count);
}

Reservoir initReservoir() {
    Reservoir r;
    r.Y = 0u;
    r.W_sum = 0.0;
    r.M = 0.0;
    return r;
}

Reservoir getPrevReservoir(ivec2 gid){
    vec4 lookup = imageLoad(img_reservoir, gid + ivec2(readOffset, 0));
    Reservoir r;
    r.Y = floatBitsToUint(lookup.x);
    r.W_y = lookup.y;
    r.W_sum = lookup.z;
    r.M = lookup.w;
    return r;
}

void writeReservoir(Reservoir r, ivec2 gid){
    imageStore(img_reservoir, gid + ivec2(writeOffset, 0), vec4(uintBitsToFloat(r.Y), r.W_y, r.W_sum, r.M));
}


float calcWeight(vec3 rad){
    //return length(rad);
    return max(dot(rad, vec3(0.2126,0.7152,0.0722)), 1e-8);
}

vec3 GetPointLightRadiance(Light l, Geom g, out float p_hat){
    vec3 d = l.pos - g.pos;
    float dist2 = max(dot(d, d), 1e-6);
    vec3 wi = d * inversesqrt(dist2);

    float ndotl = max(dot(g.nor, wi), 0.0);

    // Point light falloff 
    vec3 Li = l.col / dist2;

    // Lambertian
    vec3 brdf = g.alb / 3.14159265;

    vec3 rad = brdf * Li * ndotl;
    p_hat = calcWeight(rad);
    return rad;
}

vec2 world2texel(vec2 p){
    p.x /= ratio;
    p = p*0.5 + 0.5;
    p *= fsize;
    return p;
}

float heightAtCell(ivec2 cell)
{
    return imageLoad(img_pos, cell).z;   // height in world units 
}

float visibilityCheap(vec3 P, vec3 L, inout uint seed)
{
    const float bias = 0.00001;
    vec3 d = L - P;
    float dist = length(d);
    if (dist <= 1e-5) return 1.0;

    vec3 dir = d / dist;
    vec3 O = P + dir * bias; // avoid self hit

    vec2 g0 = world2texel(O.xy);
    vec2 g1 = world2texel(L.xy);
    vec2 dg = g1 - g0;

    // Choose a small fixed sample count, optionally based on distance in grid cells.
    float gridDist = length(dg);
    //int steps = int(clamp(gridDist * mix(0.4, 0.4, RandomFloat01(seed)), 2.0, 20.0)); // ~1 sample per 4 cells, 6..16 samples
    int steps = int(clamp(gridDist * 0.4, 6.0, 20.0));

    // March in param t in (0,1), skipping endpoints
    float divisor = 1 / float(steps + 1);
    for (int i = 1; i <= steps; ++i)
    {
        float t = (float(i)+RandomFloat01(seed)-0.5) * divisor;

        // point on segment in world space
        float z = mix(O.z, L.z, t);

        // sample terrain height at corresponding XY
        vec2 g = g0 + dg * t;
        ivec2 cell = ivec2(floor(g));

        float h = heightAtCell(cell);

        if (h > z + bias)
            return 0.0;
    }

    return 1.0;
}

void main() {

    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);

    getImageSize();

    if(gid.x >= size.x || gid.y >= size.y) return;

    uint seed = getSeed(gid);
    Geom g = getGeom(gid);
    Reservoir r = getPrevReservoir(gid);

    float p_hat = 0;

    //===== ReSTIR RESOLVE
    vec3 res = vec3(0.0);
    vec3 rad = vec3(0.0);

    if (IsReservoirValid(r))
    {
        float visibility = visibilityCheap(g.pos, lights[r.Y].pos, seed);

        rad = visibility * GetPointLightRadiance(lights[r.Y], g, p_hat);
        p_hat = calcWeight(rad);
             
        // calculate the weight of this light
        r.W_y = p_hat > 0.0 ? (r.W_sum/p_hat) / r.M : 0.0;
        
        // apply it to the radiance to get the final radiance.
        rad  *=  r.W_y;
        res += rad;
    }
    //writeReservoir(r, gid);
/*
    for(int i = 0; i < 2; i++){

        ivec2 offset = ivec2(10*(RandomVec201(seed)-0.5));
        Reservoir r = getPrevReservoir(gid + offset);

        float p_hat = 0;

        //===== ReSTIR RESOLVE
        vec3 rad = vec3(0.0);

        if (IsReservoirValid(r))
        {
            float visibility = visibilityCheap(g.pos, lights[r.Y].pos, seed);

            rad = visibility * GetPointLightRadiance(lights[r.Y], g, p_hat);
            p_hat = calcWeight(rad);
                 
            // calculate the weight of this light
            r.W_y = p_hat > 0.0 ? (r.W_sum/p_hat) / r.M : 0.0;
            
            // apply it to the radiance to get the final radiance.
            rad  *=  r.W_y;
            res += rad;
        }
    }
    res /= 3;
*/
    imageStore(img_raw_dir, gid, vec4(res, 1.0));
}